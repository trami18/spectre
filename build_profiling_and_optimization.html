<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Build Profiling and Optimization</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2021.04.06</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Build Profiling and Optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md122">Why is our build so expensive?</a></li>
<li class="level1"><a href="#autotoc_md123">Understanding template expenses</a></li>
<li class="level1"><a href="#autotoc_md124">Profiling the build</a><ul><li class="level2"><a href="#autotoc_md125">Specialized tests and feature exploration</a></li>
<li class="level2"><a href="#autotoc_md126">Templight++</a></li>
<li class="level2"><a href="#autotoc_md127">Clang AST syntax generation</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md122"></a>
Why is our build so expensive?</h1>
<p>SpECTRE makes heavy use of compile-time logic, which is responsible for a lot of the nice type-checking, performance, and flexibility the code has to offer. For instance, our central data structure, the <a class="el" href="group__DataBoxGroup.html">DataBox</a>, uses a type list of several "tags" to determine its contents, as well as to automatically propagate dependencies in compute items.</p>
<p>This use of compile-time logic, however, has the trade-off of making our builds take longer and use more memory than a similar implementation in runtime logic would. There is good reason to believe that some of these costs are payed back at runtime, because many of our compile-time switches permit the final runtime code to be more efficient or avoid unnecessary computation. There is certainly room for optimization, though, either in finding better compile-time implementations of the algorithms, eliminating expensive template instantiations, or moving inefficient parts to runtime. This guide gives a quick outline of some of the methods that can be used to profile the build and possible pitfalls</p>
<h1><a class="anchor" id="autotoc_md123"></a>
Understanding template expenses</h1>
<p>The cost of compile-time template logic is a bit non-intuitive if you are used to thinking only of runtime performance. The main reason is that the typical unit of 'cost' in a compile-time operation is the number of instantiated types and functions. Re-using a type that has been instantiated elsewhere (in the same translation unit) typically has a very low compile-time cost, where instantiating a type with new template parameters will incur its own cost, plus any new types that it requires in e.g. type aliases or member functions.</p>
<p>Consider a Fibonacci calculation at compile-time: </p><div class="fragment"><div class="line">template &lt;size_t N&gt;</div>
<div class="line">struct Fibonacci {</div>
<div class="line">  static constexpr size_t value =</div>
<div class="line">      Fibonacci&lt;N - 1&gt;::value + Fibonacci&lt;N - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;&gt;</div>
<div class="line">struct Fibonacci&lt;1&gt; {</div>
<div class="line">  static constexpr size_t value = 1;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;&gt;</div>
<div class="line">struct Fibonacci&lt;0&gt; {</div>
<div class="line">  static constexpr size_t value = 1;</div>
<div class="line">};</div>
</div><!-- fragment --><p>If we were to write the same logic at runtime, the algorithm would be hopelessly inefficient; the recursive calls would cause each call to Fibonacci to make two calls to the same function, resulting in an exponential time algorithm! However, the C++ language will only instantiate unique types, so only N types will be created, giving a linear in compile-time operation.</p>
<p>Compile-time lists and list operations frequently appear in SpECTRE, and should be thought of differently from runtime list operations.</p>
<p>In compile-time lists, we have no access to true constant-time lookup, speedy algorithms that rely on sorted structures, or more sophisticated data structures (balanced trees, hash tables, etc.). The limitations of compile-time list techniques can cause list operations to be more costly than we could achieve with runtime data structures.</p>
<p>Consider a basic version of the compile-time list accessor: </p><div class="fragment"><div class="line">template &lt;typename List, size_t Index&gt;</div>
<div class="line">struct list_at;</div>
<div class="line"> </div>
<div class="line">template &lt;typename ListItem0, typename... ListItems&gt;</div>
<div class="line">struct list_at&lt;tmpl::list&lt;ListItem0, ListItems...&gt;, 0&gt; {</div>
<div class="line">  using type = ListItem0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;typename ListItem0, typename... ListItems, size_t Index&gt;</div>
<div class="line">struct list_at&lt;tmpl::list&lt;ListItem0, ListItems...&gt;, Index&gt; {</div>
<div class="line">  using type = typename list_at&lt;tmpl::list&lt;ListItems...&gt;, Index - 1&gt;::type;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, to access the Nth item in the list, we need to instantiate \(O(N)\) types. The above implementation is significantly more costly than we would find in practice in template metaprogramming libraries &ndash; in particular, our chosen TMPL backend, <a href="https://github.com/edouarda/brigand">Brigand</a>, manages the task in \(O(\log(N))\) (at least in type instantiation count).</p>
<p>Most of the list operations in SpECTRE cannot take advantage of any particular ordering or hashing of the list, so must resort to naive list operations &ndash; so, searching a list (<code>tmpl::list_contains</code> or <code>tmpl::index_of</code>) is \(O(N)\) cost, <code>tmpl::remove_duplicates</code> is \(O(N^2)\), and <code>tmpl::list_difference</code> is similarly \(O(N^2)\). So, complicated type logic scales pretty badly with long lists, and improvements can sometimes be made by reducing a list's size or avoiding the more costly list operations when a list is known to be long.</p>
<h1><a class="anchor" id="autotoc_md124"></a>
Profiling the build</h1>
<p>In the current version of SpECTRE, the most expensive builds are the final translation units associated with the executables (particularly the most complicated executables, like Generalized Harmonic and Valencia), which should be unsurprising from the above discussion: it is in these compilation steps that we instantiate the <a class="el" href="namespaceParallel.html" title="Functionality for parallelization.">Parallel</a> components, and in turn, all of the <a class="el" href="group__DataBoxGroup.html">DataBox</a> types that will be used during the evolution.</p>
<p>Similarly, a number of tests have now shown that in the current version of SpECTRE (as of early 2021), by far the most expensive part of the build is <a class="el" href="group__DataBoxGroup.html">DataBox</a> operations and instantiations, and the best build performance gains are available by either reducing the number of <a class="el" href="group__DataBoxGroup.html">DataBox</a>es that are instantiated, reducing the number of tags (particularly compute tags) stored in the <a class="el" href="group__DataBoxGroup.html">DataBox</a>, or optimizing the implementations of the <a class="el" href="group__DataBoxGroup.html">DataBox</a> and its utilities. So, generally speaking, profiling should start by focusing on the <a class="el" href="group__DataBoxGroup.html">DataBox</a>, and move to other utilities if it becomes clear that there are other parts of the code that are contributing significantly to the compilation time or memory usage.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
Specialized tests and feature exploration</h2>
<p>This is simultaneously the most reliable and most labor-intensive strategy for understanding build costs. The procedure is to identify a feature you'd like to profile, create a specialized test for that feature, and put that test in the <code>tests/Unit/RunSingleTest/CMakeLists.txt</code>. Then, you can easily include or exclude uses of functions or classes that you want to profile, and compare the relative total cost of building <code>RunSingleTest</code>.</p>
<p>There are a number of tools for profiling the cost of an individual process, but for compilation, the detailed tools like <code>perf</code> or hpctoolkit are unlikely to give useful information about what parts of our code are slow to build. Instead, it's best to just carefully measure the full build of the target in question, and rapidly iterate to include or exclude potentially expensive parts to understand the build costs.</p>
<p>There are a lot of tools that can give you the global resource usage information, including the <code>/proc/$PID/status</code> file from kernel information, <code>top</code>, or tools from the <code>sysstat</code> package. The <code>time</code> utility is particularly user-friendly, available on ubuntu (and therefore in the SpECTRE build container) via <code>apt-get install time</code>. Then, it can be invoked by <code>/usr/bin/time -v your_command</code> (note that simply <code>time</code> will route to a different alias in the default environment on ubuntu in the container, so the full path <code>/usr/bin/time</code> is required). After completion, it will print a readable report of the time and memory usage.</p>
<p>One important feature to be aware of in profiling the build by this method is the implicit memoization of many compile-time features. For instance, if feature <code>A</code> and <code>B</code> both instantiate a class <code>C</code> that is expensive to build, you'll see a difference in the build cost when <em>either</em> <code>A</code> or <code>B</code> are included, but the cost won't be additive - the second feature will just 'reuse' the instantiation from the first. To optimize this type of situation, either <code>C</code> must be improved to be less costly to instantiate, or its use must be eliminated from <em>both</em> <code>A</code> and <code>B</code> &ndash; removing <code>C</code> from only one of the classes that use it won't help the build much at all.</p>
<h2><a class="anchor" id="autotoc_md126"></a>
Templight++</h2>
<p>Detailed profiling of a C++ build is a surprisingly hard task, and there are few useful tools for getting a good idea for what parts of a compilation are expensive. One tool that can perform some profiling of the build is <a href="https://github.com/mikael-s-persson/templight">templight++</a>. <em>It is important to note that this tool often produces build profiles that are misleading or incomplete!</em> It is included in this guide under the philosophy that a flawed tool can be better than no tool at all in some circumstances, but the templight++ profiles should be taken primarily as a loose guide for features to investigate with more careful follow-up investigations like the above suggestion of specialized tests and feature exploration.</p>
<p>The <code>templight++</code> build and usage instructions work nicely with the current SpECTRE build system, and the cmake trick suggested by the <code>templight++</code> documentation </p><div class="fragment"><div class="line">export CC=&quot;/path/to/llvm/build/bin/templight -Xtemplight -profiler\</div>
<div class="line"> -Xtemplight -memory&quot;</div>
<div class="line">export CXX=&quot;/path/to/llvm/build/bin/templight++ -Xtemplight -profiler\</div>
<div class="line"> -Xtemplight -memory&quot;</div>
</div><!-- fragment --><p>works well in SpECTRE. Build profiling with <code>templight++</code> are incredibly slow, and seem to produce increasingly misleading data for larger builds, so it is recommended to avoid using the tool for our most expensive evolution executables. Experience indicates that you will likely wait for hours and be disappointed by deeply flawed results.</p>
<p>After building a target, you will find along side each <code>.o</code> file in the <code>build/src</code> tree an additional file that ends with <code>.trace.pbf</code>. These are the <code>templight++</code> trace files, and (like many performance tool outputs), require post-processing to recover human-readable data. The companion package <a href="https://github.com/mikael-s-persson/templight-tools">templight-tools</a> can be built to obtain the <code>templight-convert</code> utility that converts the templight traces to more managable formats. It is recommended to install and use <a href="https://kcachegrind.github.io/html/Home.html">KCacheGrind</a> (which does, unfortunately require some KDE libraries, but doesn't require you to use the full KDE window system) to visualize the output &ndash; the larger graphs produced by templight are inefficient to render in the graphviz format.</p>
<h2><a class="anchor" id="autotoc_md127"></a>
Clang AST syntax generation</h2>
<p>There is a nice and poorly documented feature of the <code>clang++</code> compiler that it can produce a rough approximation of the collection of C++ template instantiations produced by a particular executable. Adding <code>-Xclang -ast-print -fsyntax-only</code> to the <code>CXX_FLAGS</code> will cause this information to be printed to stdout, which should probably be redirected to file because it will be an enormous output. Importantly, to the best of our knowledge, this tool has not yet been used to successfully profile any SpECTRE build, but with sufficient post-processing the C++-syntax version of the AST might be useful to determine the number and nature of instantiations produced by a particular piece of code, and might offer some proxy for build performance.</p>
<p>For instance, if we put the above <code>Fibonacci</code> struct in a source file with: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/cout.html">std::cout &lt;&lt; Fibonacci&lt;6&gt;::value</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and we compile it with </p><div class="fragment"><div class="line">clang++-10 -Xclang -ast-print -fsyntax-only -o fib ./fib.cpp &gt;&gt; fib_out</div>
</div><!-- fragment --><p>we obtain in <code>fib_out</code> (after thousands of lines of STL-generated code): </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>Fibonacci {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;N - 1&gt;::value + Fibonacci&lt;N - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;6&gt; {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;6UL - 1&gt;::value + Fibonacci&lt;6UL - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;5&gt; {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;5UL - 1&gt;::value + Fibonacci&lt;5UL - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;4&gt; {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;4UL - 1&gt;::value + Fibonacci&lt;4UL - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;3&gt; {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;3UL - 1&gt;::value + Fibonacci&lt;3UL - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;2&gt; {</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value =</div>
<div class="line">      Fibonacci&lt;2UL - 1&gt;::value + Fibonacci&lt;2UL - 2&gt;::value;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;1&gt; { <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value = 1; };</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Fibonacci&lt;0&gt; { <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> value = 1; };</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) { <a class="codeRef" href="http://en.cppreference.com/w/cpp/io/cout.html">std::cout &lt;&lt; Fibonacci&lt;6&gt;::value</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; }</div>
</div><!-- fragment --><p>Which is actually pretty illuminating about what the compiler decided to do in this simple case. Unfortunately, the AST produced by <code>clang++</code> in more complicated cases produces extremely large outputs, so realistic cases are likely too large to be usefully human-readable. It may be possible, though, to script post-processing tools to sift through the collections of template instantiations for particular classes to understand specific cases of template logic. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="acout_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/cout.html">std::cout</a></div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2021
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
